How the Project is to be developed, coded and executed

## âœ… Correct Development Flow (Step-by-Step)
    Think in layers, not screens.

## separation of concerns and the use of layered architecture

## A. ğŸ§± PHASE 1: Data & Domain (MOST IMPORTANT)

        Do NOT write UI first. Ever.

### 1ï¸âƒ£ Finalize the data model (lock core meaning)

    Create tables + columns and freeze their meaning.

Core Tables (minimum)

accounts
id              INTEGER PRIMARY KEY
<!-- name            TEXT NOT NULL -->
bankName        TEXT NOT NULL
type            TEXT            -- savings, current, cash, credit
currency        TEXT            -- INR
opening_balance REAL
created_at      TEXT

categories
id              INTEGER PRIMARY KEY
name            TEXT NOT NULL
type            TEXT            -- debit / credit / both
color           TEXT            -- hex code
icon            TEXT
created_at      TEXT

transactions
id              INTEGER PRIMARY KEY
amount          REAL NOT NULL           -- always positive
transaction_type TEXT NOT NULL           -- debit | credit
category_id     INTEGER
account_id      INTEGER
timestamp       TEXT NOT NULL            -- ISO 8601
note            TEXT
created_at      TEXT


ğŸ“Œ Rules

Amount is always positive

Type decides direction
Meaning never changes

2ï¸âƒ£ Decide naming conventions (donâ€™t skip)

Snake_case or camelCase â†’ pick one
Dates â†’ ISO strings only
No magic numbers

3ï¸âƒ£ Define schema version
schema_version = 1

This will save you later.

ğŸ§± PHASE 2: Data Access Layer (before UI)
4ï¸âƒ£ Setup SQLite & migrations

Create DB
Create tables
Add indexes

Example:

CREATE INDEX idx_txn_date ON transactions(timestamp);
CREATE INDEX idx_txn_category ON transactions(category_id);

5ï¸âƒ£ Write repository functions (CRUD)

Example:

addTransaction()
getTransactionsByMonth()
getSummaryByCategory()
getAccountBalance()

ğŸ“Œ At this point:

You can test everything without UI

This is the real engine of the app

ğŸ§± PHASE 3: Business Logic (still no UI)
6ï¸âƒ£ Derive computed data

Monthly totals
Quarterly totals
Account balances
Category-wise sums

Use SQL, not JS loops.

Example:

SELECT category_id, SUM(amount)
FROM transactions
WHERE transaction_type = 'debit'
AND strftime('%Y-%m', timestamp) = '2025-12'
GROUP BY category_id;

7ï¸âƒ£ Decide export format (CSV)

Column order
File naming
Schema metadata

Now your data is portable forever.

ğŸ§± PHASE 4: Minimal UI (only now)
8ï¸âƒ£ Build â€œAdd Transactionâ€ screen first

Why?

Everything depends on data entry being correct

Flow:
Input â†’ Validate â†’ Save to DB â†’ Refresh UI

No fancy design yet.

9ï¸âƒ£ Build Summary screen

Monthly
Quarterly
Yearly

Simple totals first

Charts later

ğŸ”Ÿ Build Accounts screen

Masked balance
Press-to-reveal

Calculated from DB, not stored blindly

ğŸ§± PHASE 5: UX polish & safety
1ï¸âƒ£1ï¸âƒ£ Add safeguards

Confirm delete
Prevent negative amounts
Category required
Backup reminders

1ï¸âƒ£2ï¸âƒ£ Add CSV export

Button in settings
One table = one CSV
Add metadata JSON

Now your app is future-proof.

ğŸ§± PHASE 6: Hardening & scale (optional)
1ï¸âƒ£3ï¸âƒ£ Performance checks

Large dataset test
Index verification

1ï¸âƒ£4ï¸âƒ£ Prep for backend (not implement)

Keep repository pattern
Avoid tight coupling
Document schema

ğŸ§  Mental Model (remember this)
DATA â†’ LOGIC â†’ UI â†’ POLISH

âŒ Not:
UI â†’ logic â†’ panic â†’ rewrite

ğŸ”‘ Why this flow matters (especially for you)

Your data is precious
You want long-term usage
You want upgrade safety
You might add backend later

This flow ensures:
âœ”ï¸ No data loss
âœ”ï¸ Easy migrations
âœ”ï¸ Clean code
âœ”ï¸ Professional-grade design

ğŸ”œ Next Step (tell me which one)

I can now:

Lock final DB schema v1 with you
Design SQLite queries for summaries
Draft CSV export spec
Help you scaffold the project (Expo vs CLI)

Say the word â€” weâ€™ll go step by step.

## Before DB Initializaiton let create Expo app and install dependencies

create Expo app
    npx create-expo-app .

install dependencies
    npx expo install expo-sqlite

## STEP 2 â€” DB Initialization using expo-sqlite

What we are building (high-level)

On app startup:
    Open SQLite DB
    â†“
    Ensure appMeta table exists
    â†“
    Read current schemaVersion from DB
    â†“
    Compare with SCHEMA_VERSION (from schemaVersion.ts)
    â†“
    Run pending migrations in order
    â†“
    Update schemaVersion in DB

### 1ï¸âƒ£ Install & import SQLite (Expo)

You already likely have this, but for clarity:
  npx expo install expo-sqlite

### 2ï¸âƒ£ Folder structure (recommended)

    db/
     â”œâ”€â”€ migrations/
     â”‚    â”œâ”€â”€ 001_init.sql
     â”‚    â”œâ”€â”€ 002_add_tags.sql
     â”‚    â””â”€â”€ 003_add_indexes.sql
     â”œâ”€â”€ schemaVersion.ts
     â”œâ”€â”€ db.ts          ğŸ‘ˆ we create this now
     â””â”€â”€ migrate.ts     ğŸ‘ˆ optional separation

Weâ€™ll keep things readable.

3ï¸âƒ£ db.ts â€” open SQLite database
// db/db.ts
import * as SQLite from 'expo-sqlite';
<!-- export const db = SQLite.openDatabase('moneywise.db'); 
SQLite SDK API end point chnaged-->
export const db = SQLite.openDatabaseSync('moneywise.db');

ğŸ“Œ This:
Creates DB if not present
Opens existing DB otherwise

4ï¸âƒ£ Helper: run SQL safely (VERY IMPORTANT)

Expo SQLite is callback-based.
We wrap it in Promises so migrations run in order.

```ts
inCORRECT EXECUTION:

// db/executeSql.ts
import { db } from './db';

export function executeSql(sql: string): Promise<void> {
  return new Promise((resolve, reject) => {
    db.exec(
      [{ sql, args: [] }],
      false,
      (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      }
    );
  });
}

// âœ… Correct executeSql using new API
// db/executeSql.ts
import { db } from './db';

export async function executeSql(sql: string) {
  await db.execAsync(sql);
}

// Thatâ€™s it.
// No callbacks. No Promise wrappers. Much cleaner.

```

ğŸ“Œ This ensures:

Migrations donâ€™t overlap
Errors stop execution immediately


-----------------------------------------------------------------------------------

The conceptual flow does NOT change:

Ensure appMeta exists
â†“
Read schemaVersion from DB
â†“
Compare with code's SCHEMA_VERSION
â†“
Run missing migrations in order
â†“
Update schemaVersion in DB

-----------------------------------------------------------------------------------
5ï¸âƒ£ DB Initialization & Migration Logic (CORE)

initDatabase.ts
// db/initDatabase.ts
```ts
import { db } from './db';
import { executeSql } from './executeSql';
import { SCHEMA_VERSION, MIGRATIONS } from './schemaVersion';

export async function initDatabase() {
  console.log('Initializing database...');

  // 1ï¸âƒ£ Ensure appMeta table exists
  await executeSql(`
    CREATE TABLE IF NOT EXISTS appMeta (
      key TEXT PRIMARY KEY,
      value TEXT
    );
  `);

  // 2ï¸âƒ£ Read current schema version
  const currentVersion = await getCurrentSchemaVersion();
  console.log('Current schema version:', currentVersion);

  // 3ï¸âƒ£ Apply pending migrations
  for (const migration of MIGRATIONS) {
    if (migration.version > currentVersion) {
      console.log(`Running migration v${migration.version}`);
      const sql = await loadMigrationFile(migration.file);
      await executeSql(sql);
      await setSchemaVersion(migration.version);
    }
  }

  console.log('Database ready');
}
```

6ï¸âƒ£ Read & write schemaVersion (DB truth)

```ts
async function getCurrentSchemaVersion(): Promise<number> {
  return new Promise((resolve) => {
    db.transaction((tx) => {
      tx.executeSql(
        `SELECT value FROM appMeta WHERE key = 'schemaVersion'`,
        [],
        (_, result) => {
          if (result.rows.length === 0) {
            resolve(0); // fresh install
          } else {
            resolve(Number(result.rows.item(0).value));
          }
        }
      );
    });
  });
}

async function setSchemaVersion(version: number) {
  await executeSql(`
    INSERT OR REPLACE INTO appMeta (key, value)
    VALUES ('schemaVersion', '${version}');
  `);
}
```

7ï¸âƒ£ Loading .sql migration files

Since Expo bundles files, simplest approach is:

Option A (recommended initially)
Import SQL as strings manually:
```ts
// db/migrations/index.ts
import init from './001_init.sql?raw';
import addTags from './002_add_tags.sql?raw';
import addIndexes from './003_add_indexes.sql?raw';

export const MIGRATION_SQL: Record<string, string> = {
  '001_init.sql': init,
  '002_add_tags.sql': addTags,
  '003_add_indexes.sql': addIndexes,
};

// Then:

import { MIGRATION_SQL } from './migrations';

async function loadMigrationFile(file: string): Promise<string> {
  return MIGRATION_SQL[file];
}
```

ğŸ“Œ This avoids filesystem permission complexity early on.

8ï¸âƒ£ Call DB init at app startup

In App.tsx:

```ts
useEffect(() => {
  initDatabase()
    .then(() => console.log('DB initialized'))
    .catch(console.error);
}, []);
```

ğŸš« Do not render DB-dependent screens before this finishes.

9ï¸âƒ£ What you have achieved now

âœ”ï¸ Schema v1 auto-creates
âœ”ï¸ Fresh install works
âœ”ï¸ Old installs migrate safely
âœ”ï¸ Version tracked in DB
âœ”ï¸ Git tracks schema history
âœ”ï¸ Zero data loss risk

This is professional-grade migration handling.

10ï¸âƒ£ Common mistakes to avoid (important)

âŒ Running migrations inside UI components
âŒ Running all SQL every startup
âŒ Not tracking schemaVersion in DB
âŒ Skipping error handling

You avoided all of these ğŸ‘

Your NEXT step (Step 3)

ğŸ‘‰ Test this flow:
  Delete app â†’ fresh install â†’ DB creates
  Add fake schemaVersion = 0 â†’ see migrations run
  Add new migration â†’ confirm only new SQL runs

When ready, say:
â€œGuide me through CSV export implementation nowâ€

Weâ€™ll then:
  Write export queries
  Generate CSV safely
  Version exports
  Save files properly on Android

